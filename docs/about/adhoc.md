<!--  
3 tiers.

Codiac acts as your broker for the activities within your project.

(we get context out of it, which makes a huge difference in time money and manpoewer)

-->


(you dont knwo the world of contextual dev.  And we found that it is a better way to wrk)

What is Context?
Versions, Assets, environments, deplyments, configurations

Why do we need it? 

Do we really need a whole devops automation team to get our software out the door? 

brittle static confg files
human err
repeating ourselves
storing info where it shdnt be
look automated but arent (autopmation by human effort)
skeletons in the closet / bodies buried
cuz working working without it requires toolchaining and repeating ourselves.

SO codiac is brinign thesew missing layers to the table into all phases, 


Codiac CLI integrates third party tools to create a seamless development experience for next level ease, scale, and visibility. 

We make the things that you do easier to do b y adding context to it

(We do this by bringing context to the 3 tiers)

(fyi: there are benefits to having context and state)

(, providing context and state for your projects, with awareness of  development, runtime, and infrastructure)
(does the tool-chaining for you)

**Use the Codiac CLI and portal instead of interfacing directly with your third party tools (*eg: npm, docker, git, kubernetes, azure...*), to safely and seamlessly get your product to the cloud with next-level ease, scale, and visibility.**

*(It's a dev ops tool, a seamless one-stop-shop software automation tool to get you to the cloud.) (cabinet?  versions?  esm?)*


Engineering design has been getting sidelined by imeplemenation.


That guy is right.  Heâ€™s a technician, and in the current state of affairs, the best value he can provide is to lookup, learn, and knit together microframeworks and microsolutions.  On top of that, his role in a properly functioning software company is shrinking because he can't possibly handle all of that by himself.  

And what do you expect to get for a product that was assembled with mostly implementation and hardly any design?  You get a typically difficult to maintain hodge podge of implementations. = cumbersome.
